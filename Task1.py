import timeimport numpy as npfrom matplotlib import pyplot as pltimport mathdef main():    def visual(teor, emp, name):        fig, ax = plt.subplots()        ax.plot(emp, label='Experimental results')        ax.plot(teor, label='Approximation based on theoretical estimates')        ax.set_title(f'{name}', fontsize=24)        ax.set_xlabel('Dimension of the vector v', fontsize=14)        ax.set_ylabel('Time (seconds)', fontsize=14)        plt.grid()        ax.legend()        # ax.axis([0, 100, -0.000001, 0.00001])        plt.show()    def aproximation(name, time_list):        def aprox_n_n(time_list):            const = 0            n_square = [n ** 2 for n in range(1, len(time_list) + 1)]            n_fourth = np.array([[n ** 4 for n in range(1, len(time_list) + 1)]])            for i in range(len(time_list)):                const += n_square[i] * time_list[i]            return const / np.sum(n_fourth)        def aprox_n(time_list):            const = 0            n = [n for n in range(1, len(time_list) + 1)]            n_square = np.array([[n ** 2 for n in range(1, len(time_list) + 1)]])            for i in range(len(time_list)):                const += n[i] * time_list[i]            return const / np.sum(n_square)        def aprox_n_logn(time_list):            const = 0            n = [(n * math.log(n)) for n in range(1, len(time_list) + 1)]            n_square = np.array([[(n ** 2) * (math.log(n) ** 2) for n in range(1, len(time_list) + 1)]])            for i in range(len(time_list)):                const += n[i] * time_list[i]            return const / np.sum(n_square)        def aprox_n_n_n(time_list):            const = 0            n_square = [n ** 3 for n in range(1, len(time_list) + 1)]            n_fourth = np.array([[n ** 6 for n in range(1, len(time_list) + 1)]])            for i in range(len(time_list)):                const += n_square[i] * time_list[i]            return const / np.sum(n_fourth)        if name == 'aprox_n_n':            return aprox_n_n(time_list)        elif name == 'aprox_n':            return aprox_n(time_list)        elif name == 'aprox_n_logn':            return aprox_n_logn(time_list)        elif name == 'aprox_n_n_n':            return aprox_n_n_n(time_list)    def task_1():        # a random vector        v = np.random.uniform(1, 1000, 2000)        # lists to record runtime        list_const_function = []        list_sum_of_elements = []        list_product_of_elements = []        list_direct_polinom = []        list_method_of_horner = []        list_bubble_sort = []        list_quick_sort = []        list_timsort = []        list_product_matrix = []        def const_function():            for n in range(2000):                start = time.time()                for i in range(5): # 5 cycles to record the average value                    x = 0.0                end = time.time()                list_const_function.append((end - start) / 5)            # recording theoretical time data            t_const_function = [0.00000004 for n in range(1, 2001)]            def visual_const(name):                # const function                fig, ax = plt.subplots()                ax.plot(list_const_function, label='experimental results')                ax.plot(t_const_function, label='theoretical results')                ax.set_title(f'{name}', fontsize=24)                ax.set_xlabel('Dimension of the vector v', fontsize=14)                ax.set_ylabel('Time (seconds)', fontsize=14)                plt.grid()                ax.legend()                ax.axis([0, 2000, -0.0000001, 0.000006])                plt.show()            visual_const('constant function')        def sum_of_elements(v):            for n in range(2000):                start = time.time()                for i in range(5):                    for i in range(n + 1):                        x = 0                        x += v[i]                end = time.time()                list_sum_of_elements.append((end - start) / 5)            t_sum_of_elements = [n * aproximation('aprox_n', list_sum_of_elements) for n in range(1, 2001)]            visual(t_sum_of_elements, list_sum_of_elements, 'the sum of elements')        def product_of_elements(v):            for n in range(2000):                start = time.time()                for i in range(5):                    for i in range(n + 1):                        x = 1                        x *= v[i]                end = time.time()                list_product_of_elements.append((end - start) / 5)            t_product_of_elements = [n * aproximation('aprox_n', list_product_of_elements) for n in range(1, 2001)]            visual(t_product_of_elements, list_product_of_elements, 'the product of elements')        def direct_polinom(v):            for n in range(500):                start = time.time()                for i in range(5):                    x = 1.5                    P = 0                    for i in range(n): # calculation of the degree by a linear method                        a = 1                        for k in range(i):                            a *= x                        P += v[i] * a                end = time.time()                list_direct_polinom.append((end - start) / 5)            t_direct_polinom = [(n ** 2) * aproximation('aprox_n_n', list_direct_polinom) for n in range(1, 501)]            visual(t_direct_polinom, list_direct_polinom, 'direct polynomial algorithm')        def method_of_horner(v):            for n in range(500):                start = time.time()                for i in range(5):                    x = 1.5                    P = x * v[n - 1]                    for i in reversed(range(1, n - 1)):                        P = x * (P + v[i])                    P += v[0]                end = time.time()                list_method_of_horner.append((end - start) / 5)            t_method_of_horner = [n * aproximation('aprox_n', list_method_of_horner) for n in range(1, 501)]            visual(t_method_of_horner, list_method_of_horner, 'Horner`s method')        def bubble_sort(v):            for n in range(500):                v_sort = []                v_sort.extend(v[:n + 1])                start = time.time()                for i in range(5):                    for i in range(n):                        for j in range(n - i):                            if v_sort[j] > v_sort[j + 1]:                                v_sort[j], v_sort[j + 1] = v_sort[j + 1], v_sort[j]                end = time.time()                list_bubble_sort.append((end - start) / 5)            t_bubble_sort = [(n ** 2) * aproximation('aprox_n_n', list_bubble_sort) for n in range(1, 501)]            visual(t_bubble_sort, list_bubble_sort, 'Bubble Sort')        def quick_sort(v):            for n in range(2000):                # create 5 subarrays                v_sort1, v_sort2, v_sort3, v_sort4, v_sort5 = [], [], [], [], []                v_sort1.extend(v[:n + 1])                v_sort2.extend(v[:n + 1])                v_sort3.extend(v[:n + 1])                v_sort4.extend(v[:n + 1])                v_sort5.extend(v[:n + 1])                def q_sort(v):                    if len(v) <= 1:                        return v                    e = v[0]                    l = list(filter(lambda x: x < e, v))                    c = [i for i in v if i == e]                    r = list(filter(lambda x: x > e, v))                    return q_sort(l) + c + q_sort(r)                start = time.time()                q_sort(v_sort1)                q_sort(v_sort2)                q_sort(v_sort3)                q_sort(v_sort4)                q_sort(v_sort5)                end = time.time()                list_quick_sort.append((end - start) / 5)            t_quick_sort = [(n * math.log(n)) * aproximation('aprox_n_logn', list_quick_sort) for n in range(1, 2001)]            visual(t_quick_sort, list_quick_sort, 'Quick Sort')        def timsort(v):            for n in range(2000):                v_sort = []                v_sort.extend(v[:n + 1])                start = time.time()                for i in range(5):                    sorted(v_sort) # the function does not change the vector                end = time.time()                list_timsort.append((end - start) / 5)            t_timsort = [(n * math.log(n)) * aproximation('aprox_n_logn', list_timsort) for n in range(1, 2001)]            visual(t_timsort, list_timsort, 'Timsort')        def product_matrix():            for i in range(1, 151):                A = np.random.sample((i + 1, i + 1))                B = np.random.sample((i + 1, i + 1))                start = time.time()                for i in range(5):                    length = len(A)                    if len(A) == 1:                        C = [A[0] * B[0]]                    else:                        C = [[0 for i in range(length)] for i in range(length)]                        for i in range(length):                            for j in range(length):                                for k in range(length):                                    C[i][j] += A[i][k] * B[k][j]                end = time.time()                list_product_matrix.append((end - start) / 5)            t_product_matrix = [(n ** 3) * aproximation('aprox_n_n_n', list_product_matrix) for n in range(1, 151)]            visual(t_product_matrix, list_product_matrix, 'the usual matrix product for A and B')        def menu():            choice = int(input(f"0.Exit\n"                               f"1.constant function\n"                               f"2.the sum of elements\n"                               f"3.the product of elements\n"                               f"4.direct polynomial algorithm\n"                               f"5.Horner`s method\n"                               f"6.Bubble Sort\n"                               f"7.Quick Sort\n"                               f"8.Timsort\n"                               f"9.the usual matrix product for A and B\n"                               f"please choose from 0 to 9: "))            if choice == 1:                const_function()            elif choice == 2:                sum_of_elements(v)            elif choice == 3:                product_of_elements(v)            elif choice == 4:                direct_polinom(v)                print('please wait..')            elif choice == 5:                method_of_horner(v)            elif choice == 6:                print('please wait..')                bubble_sort(v)            elif choice == 7:                print('please wait..')                quick_sort(v)            elif choice == 8:                timsort(v)            elif choice == 9:                print('please wait..')                product_matrix()        menu()    task_1()main()